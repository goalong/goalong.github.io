<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Go,">










<meta name="description" content="笔记内容来自雨痕的《go学习笔记》。 变量类型决定了变量内存的长度和存储格式，我们只能修改变量值，无法改变类型。 用var声明变量，类型放在变量名后 var x int //        会被自动初始化为其零值 var y = false //  显式提供初始化值，可省略变量类型 var x, y int //    同类型的多个变量 var a, s = 100, &amp;quot;abc&amp;quot">
<meta name="keywords" content="Go">
<meta property="og:type" content="article">
<meta property="og:title" content="Go读书笔记总结">
<meta property="og:url" content="http://goalong.github.io/2019/03/02/go读书笔记总结/index.html">
<meta property="og:site_name" content="along&#39;s space">
<meta property="og:description" content="笔记内容来自雨痕的《go学习笔记》。 变量类型决定了变量内存的长度和存储格式，我们只能修改变量值，无法改变类型。 用var声明变量，类型放在变量名后 var x int //        会被自动初始化为其零值 var y = false //  显式提供初始化值，可省略变量类型 var x, y int //    同类型的多个变量 var a, s = 100, &amp;quot;abc&amp;quot">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://i.loli.net/2019/02/16/5c68017685d43.png">
<meta property="og:image" content="https://i.loli.net/2019/02/16/5c68017687963.png">
<meta property="og:image" content="https://i.loli.net/2019/02/22/5c6f61f912da6.png">
<meta property="og:image" content="https://i.loli.net/2019/02/22/5c6f628b6cc3b.png">
<meta property="og:updated_time" content="2019-03-04T09:10:52.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Go读书笔记总结">
<meta name="twitter:description" content="笔记内容来自雨痕的《go学习笔记》。 变量类型决定了变量内存的长度和存储格式，我们只能修改变量值，无法改变类型。 用var声明变量，类型放在变量名后 var x int //        会被自动初始化为其零值 var y = false //  显式提供初始化值，可省略变量类型 var x, y int //    同类型的多个变量 var a, s = 100, &amp;quot;abc&amp;quot">
<meta name="twitter:image" content="https://i.loli.net/2019/02/16/5c68017685d43.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://goalong.github.io/2019/03/02/go读书笔记总结/">





  <title>Go读书笔记总结 | along's space</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">along's space</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-算法">
          <a href="/lc/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-flag"></i> <br>
            
            算法
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://goalong.github.io/2019/03/02/go读书笔记总结/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="along">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="along's space">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Go读书笔记总结</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-02T00:00:00+08:00">
                2019-03-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>笔记内容来自雨痕的《go学习笔记》。</p>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>类型决定了变量内存的长度和存储格式，我们只能修改变量值，无法改变类型。</p>
<p>用var声明变量，类型放在变量名后</p>
<pre><code>var x int //        会被自动初始化为其零值
var y = false //  显式提供初始化值，可省略变量类型
var x, y int //    同类型的多个变量
var a, s = 100, &quot;abc&quot; //   不同类型的初始化值
x := 100 //简短的声明变量的方法，只能在函数内部使用， 对于多个变量的简短模式，部分可能是赋值，但必须有至少一个是新变量被定义

x, y = y+3, x+2 // 赋值时首先计算出所有右值，然后依次完成赋值操作
x, _ := strconv.Atoi(&quot;12&quot;) //   和Python类似，也有个_占位符，空标志符可用来临时规避对未使用变量和导入包的错误检查，它是预置成员，不能重新定义
</code></pre><p>支持用汉字等Unicode字符命名，但不推荐。</p>
<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>常量值必须是编译期可确定的字符、字符串、数字或布尔值。<br>声明方式：const x = 123，常量组中如不指定类型和初始化值，则与上一行非空常量右值相同。</p>
<pre><code>const (
    x uint = 120
    y // 与上面x相同

)
</code></pre><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><pre><code>const (
    x =iota // 0
    y // 1
    z // 2
    ）

const (
    _, _ = iota, iota * 10 // 0, 0*10
    a, b // 1, 1*10
    c, d // 2, 2*10
    )
</code></pre><p>如中断iota自增，必须显式恢复，且后续自增值按行序递增。</p>
<h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><p>byte和rune都是别名。<br>byte：alias for uint8（1字节)<br>rune: alias for int32 (4字节 代表unicode的code point)</p>
<p>基本类型：</p>
<p><img src="https://i.loli.net/2019/02/16/5c68017685d43.png" alt="屏幕快照 2019-02-16 下午8.25.09.png"><br><img src="https://i.loli.net/2019/02/16/5c68017687963.png" alt="屏幕快照 2019-02-16 下午8.26.12.png"></p>
<h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><p>所谓引用类型特指slice、map、channel这三种预定义类型，引用类型要使用make函数创建，以完成内存分配和属性初始化。</p>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>除常量、别名类型以及未命名类型外，Go强制要求使用显式类型转换。</p>
<h3 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a>自定义类型</h3><p>使用type 关键字可以定义用户自定义类型</p>
<pre><code>type flags byte
type (  // 多个定义可以合并成组，可在函数或代码块内定义局部类型
    user struct {
        name string
          age uint8 
     }
    event func(string) bool
)
type data int
var d data = 10
var x int = d //   错误: cannot use d (type data) as type int in assignment
</code></pre><p>基础类型相同但仍然是两种完全不同的类型，不能视作别名，无法进行比较以及隐士转换。</p>
<h3 id="未命名类型"><a href="#未命名类型" class="headerlink" title="未命名类型"></a>未命名类型</h3><p>array、slice、map、channel等类型与具体元素的类型或长度等属性有关，称为未命名类型，可用type为其提供命名以变为命名类型。</p>
<p><img src="https://i.loli.net/2019/02/22/5c6f61f912da6.png" alt="屏幕快照 2019-02-22 上午10.42.30.png"></p>
<p><img src="https://i.loli.net/2019/02/22/5c6f628b6cc3b.png" alt="屏幕快照 2019-02-22 上午10.46.19.png"></p>
<h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>内存地址是内存中每个字节单元的唯一编号，指针是一个实体，相当于一个专门用来保存地址的数字变量。</p>
<p>零长度的对象的地址不等于nil.</p>
<pre><code>var a, b struct{}
println(&amp;a == &amp;b, &amp;a == nil) // 结果是 true false
</code></pre><p>指针运算符*为左值时，用于更新目标对象状态，为右值时用于获取目标对象状态</p>
<h3 id="流控制"><a href="#流控制" class="headerlink" title="流控制"></a>流控制</h3><pre><code>// if else，支持初始化语句
if num:=9;num&lt;0{
    fmt.Println(num,&quot;is negative&quot;)
}else if num&lt;10{
    fmt.Println(num,&quot;has 1 digit&quot;)
}else{
    fmt.Println(num,&quot;has multiple digits&quot;)
}

// switch 语句
v := 3
switch  {
case v % 2 == 0:
    fmt.Println(&quot;v is even&quot;)
case v % 2 == 1:
    fmt.Println(&quot;v is odd&quot;)
}

// for循环，有几种形式,
// for init; condition; post { }
// for condition { }
for i:= 0; i &lt; 10; i++ {
    if i % 2 == 0 {
        continue
    }
    fmt.Println(i)
}
</code></pre><p>还可以用for range对数组、切片、map等结构进行迭代，返回索引、键值等数据。</p>
<p>注意普通for循环及range迭代，定义的局部变量会重复使用</p>
<pre><code>data := [3]string{&quot;a&quot;, &quot;b&quot;, &quot;c&quot;}
for i, s := range data {
    fmt.Println(&amp;i, &amp;s)
</code></pre><p>输出：</p>
<pre><code>0xc82003fe98 0xc82003fec8
0xc82003fe98 0xc82003fec8
0xc82003fe98 0xc82003fec8
</code></pre><p>range会复制目标数据，array的话复制开销会较大。</p>
<h3 id="延迟调用"><a href="#延迟调用" class="headerlink" title="延迟调用"></a>延迟调用</h3><p>向当前函数注册稍后执行的函数调用，直到当前函数执行结束前才被调用，常用于资源释放、错误处理等，多个延迟注册按先进后出顺序执行。延迟调用开销较大，影响性能。</p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>函数是第一类对象，第一类对象指可在运行期创建，可用作函数参数或返回值，可存入变量的实体。</p>
<p>不管是指针、引用类型还是其他类型参数，都是值拷贝类型，无非是拷贝目标对象还是拷贝指针自身而已。</p>
<p>变参本质是slice, 需放在参数的最后。</p>
<p>闭包， 是函数和引用环境组合体，可以引用其环境变量。</p>
<p>可在函数内部定义匿名函数，形成类似函数嵌套的效果</p>
<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>panic会立即中断当前函数流程，出发执行延迟调用，在延迟调用函数中，recover可以捕获并返回panic提交的错误。recover函数必须在延迟调用函数中才起作用。</p>
<p>除非是导致系统无法正常工作的错误，否则不建议使用panic.</p>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>字符串是不可变字节序列，</p>
<pre><code>type stringStruct struct {
    str unsafe.Pointer
    len int
}
</code></pre><p>内置函数len返回字节数组长度。</p>
<p>使用for遍历字符串时，分byte和rune两种方式</p>
<pre><code>s := &quot;hi你&quot;
for i:=0; i &lt; len(s); i++ {  // 按字节迭代
    fmt.Printf(&quot;%d: %c\n&quot;, i, s[i])
}

for i, c := range s {  // 使用for range来按字符迭代
    fmt.Printf(&quot;%d: %c\n&quot;, i, c)
}
</code></pre><p>输出：</p>
<pre><code>0: h
1: i
2: ä
3: ½
4:  
0: h
1: i
2: 你
</code></pre><p>类型rune专门用来存储Unicode Code Point, 它是int32的别名，使用单引号的字面量，其默认类型就是rune.</p>
<p>要修改字符串，需要先将其转换为可变类型([]byte或者[]rune)，这都需要重新分配内存，并复制数据。</p>
<p>动态构建字符串容易造成性能问题，用加法操作符每次都需重新分配内存。改进方法是用strings.Join().</p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组长度是其类型的一部分，也就是说[2]int和[3]int类型不同。</p>
<p>多维数组中，len和cap都返回第一纬度长度。</p>
<p>Go数组是值类型，赋值和传参都会复制整个数组内容，可改用指针或slice避免。</p>
<h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><p>切片内部通过指针引用底层数组，当需要时会申请更大内存，将当前数据复制过去，以实现类似动态数组的功能。</p>
<pre><code>type slice struct {
    array unsafe.Pointer
    len   int
    cap   int
}
</code></pre><p>属性cap表示切片所引用数组片段真实长度，len用于限定可读写数量。不支持比较操作，仅能判断是否为nil.</p>
<p>将切片作为切片的数据源，不能超出cap，新建切片对象依旧指向原底层数组，也就是说修改对所有关联可见。</p>
<p>append, 向切片尾部添加数据，并返回新的切片对象，数据被追加到原底层数组，如超出cap限制，则为新切片对象重新分配数组。</p>
<p>copy, 在两个切片对象间复制数据，允许指向同一地层数组，允许目标区间重叠，最终所复制的长度以较短的切片len为准。还可直接从字符串复制数据到[]byte.</p>
<pre><code>b := make([]byte, 3)
n := copy(b, &quot;abcde&quot;)
</code></pre><h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><p>是引用类型，使用make函数或初始化表达式创建。键值必须是支持相等运算符(==、！=)的数据类型，例如数字、字符串、指针、数组、结构体，及其对应接口类型。</p>
<pre><code>m := map[string]int{
        &quot;a&quot;: 1,
        &quot;b&quot;: 2, 
    }
m[&quot;a&quot;] = 10 //修改
m[&quot;c&quot;] = 30 //新增
v, ok := m[&quot;d&quot;] // 判断键是否存在
delete(m, &quot;d&quot;) // 删除键值对，不存在时不报错
</code></pre><p>访问不存在的键值，默认返回零值，不会报错。不能修改值成员(值为结构或数组的其中的成员）</p>
<p>内容为空的字典与nil是不同的。</p>
<pre><code>var m1 map[string]int
m2 := map[string]int{}
fmt.Println(m1 == nil, m2 == nil) // true false
</code></pre><p>在迭代期间删除或新增键值是安全的。</p>
<p>运行时会对字典并发操作作出检测，如某个goroutine正在对字典进行写操作，则其他goroutine就不能对该字典执行并发操作（读写、删除), 否则会导致进程崩溃。可使用sync.RWMutex实现并发同步，避免读写同时发生，</p>
<p>在创建时预先准备足够空间有助于提升性能，减少扩张时内存分配和重新哈希操作。例如make(map[int]int, 100).</p>
<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>结构体将多个不同类型命名字段序列打包成一个复合类型。字段名必须唯一，可用_补位，支持使用自身类型的指针成员。字段名、排列顺序属类型组成部分。可按顺序初始化全部字段，或使用命名方式初始化指定字段。推荐使用命名初始化方式，这样在扩充结构字段或调整字段顺序时，不会导致初始化语句出错。</p>
<p>可直接定义匿名结构类型变量，或用作字段类型。近在字段类型全部支持时，才可做相等操作。可使用指针直接操作结构字段。</p>
<p>空结构(struct{})是指没有字段的结构类型，它比较特殊，是因为无论其自身，还是作为数组元素类型，其长度都为零。</p>
<pre><code>var a struct{}
var b [100]struct{}
fmt.Println(unsafe.Sizeof(a), unsafe.Sizeof(b)) // 0 0
</code></pre><p>匿名字段是指没有名字仅有类型的字段，也被称为嵌入字段或嵌入类型。从编译器角度看，这是隐式以类型标识作名字的字段。不能讲基础类型和其指针类型同时嵌入，因为两者字段名字相同。</p>
<p>字段标签（tag)并不是注释，而是对字段进行描述的元数据，是类型的组成部分。在运行期，可用反射获取标签信息，常被用作格式校验，数据库关系映射等。</p>
<p>内存布局，不管结构体包含多少字段，其内存总是一次性分配的，各字段在相邻的地址空间按定义顺序排列。</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>方法与函数的区别在于有个前置的实例接收参数。可使用实例值或指针调用方法。</p>
<p>如何确定方法的receiver类型？</p>
<ul>
<li>要修改实例状态，用 *T</li>
<li>无需修改状态，小对象或固定值，建议用T</li>
<li>大对象建议用*T, 减少复制成本</li>
<li>引用类型、字符串、函数等指针包装对象，直接用T</li>
<li>包含Mutex等同步字段，用*T，避免复制造成锁操作无效</li>
<li>实在搞不清，就都用*T</li>
</ul>
<p>类型有一个与之相关的方法集合(method set), 这决定了它是否实现某个接口。</p>
<p>method value被赋值给变量或作为参数传递时，会立即计算并复制该方法执行时的receiver对象，与其绑定，以便在稍后执行时，能隐式传入receiver参数。</p>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口代表一种调用契约，是多个方法声明的集合。只要目标类型方法集内包含接口的全部方法就被视为实现了该接口，无需显示声明。</p>
<p>接口习惯以er作为名称后缀，方法名是声明组成部分，参数名可不同或省略。</p>
<p>空接口可被赋值为任何类型的对象。可以嵌入其他接口，相当于将其声明的方法集导入。嵌入的接口不能有同名方法，不能嵌入自身或循环嵌入。</p>
<p>执行机制，略。</p>
<p>类型转换，略。</p>
<h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p>并发：逻辑上具备处理多个同时性任务的能力<br>并行：物理上同一时刻执行多个并发任务</p>
<p>在函数调用前添加go关键字即可创建并发任务，新建任务被放置在系统队列中，等待调度器安排合适的系统线程去获取执行，当前流程不会阻塞，且运行时不保证并发任务执行次序。</p>
<p>每个任务单元除保存函数指针、调用参数外，还会分配执行所需的栈内存空间，相比系统默认MB级别的线程栈，goroutine自定义栈初始仅需2KB，所以才能创建成千上万的并发任务。与defer一样，goroutine也会因延迟执行而立即计算并复制执行参数。</p>
<p>进程退出时不会等待并发任务结束，可用通道阻塞，然后发出退出信号。如要等待多个任务结束，推荐使用sync.WaitGroup, 通过设定计数器，让每个goroutine在退出前递减，直至归零时解除阻塞。</p>
<pre><code>exit := make(chan struct{})
go func() {
    time.Sleep(time.Second)
    fmt.Println(&quot;goroutine done.&quot;)
    close(exit) //关闭通道，发出信号
}()
fmt.Println(&quot;main ...&quot;)
&lt;-exit // 如通道关闭，立即解除阻塞
fmt.Println(&quot;main exit.&quot;)
</code></pre><p>运行时可能会创建很多线程，但任何时候仅有限的几个参与并发任务的执行，默认与处理器核数相等，可用runtime.GOMAXPROCS函数修改。</p>
<p>Gosched, 暂停，释放线程去执行其他任务，当前任务被放回队列，等待下次调度时恢复执行。</p>
<p>Goexit, 立即终止当前任务，运行时确保所有已注册延迟调用被执行。如果让main goroutine调用Goexit, 它会等待其他任务结束，然后让进程直接崩溃。</p>
<h3 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h3><p>Go鼓励使用CSP通道，以通讯来代替内存共享，实现并发安全。</p>
<p>内置函数cap和len返回缓冲区大小和当前已缓冲数量。</p>
<p>对于closed或nil通道，发送和接收有如下规则：</p>
<ul>
<li>向closed channel发送数据，引发panic</li>
<li>从closed channel接收数据，返回已缓冲数据或零值</li>
<li>无论收发，nil channel都会阻塞</li>
</ul>
<p>select, 略。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Go/" rel="tag"># Go</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/03/01/Python进阶/" rel="next" title="Python高级用法">
                <i class="fa fa-chevron-left"></i> Python高级用法
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/03/21/go-interface/" rel="prev" title="Go接口的使用">
                Go接口的使用 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">along</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">62</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">20</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#变量"><span class="nav-number">1.</span> <span class="nav-text">变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常量"><span class="nav-number">2.</span> <span class="nav-text">常量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#枚举"><span class="nav-number">3.</span> <span class="nav-text">枚举</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基本类型"><span class="nav-number">4.</span> <span class="nav-text">基本类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#引用类型"><span class="nav-number">5.</span> <span class="nav-text">引用类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类型转换"><span class="nav-number">6.</span> <span class="nav-text">类型转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自定义类型"><span class="nav-number">7.</span> <span class="nav-text">自定义类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#未命名类型"><span class="nav-number">8.</span> <span class="nav-text">未命名类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#指针"><span class="nav-number">9.</span> <span class="nav-text">指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#流控制"><span class="nav-number">10.</span> <span class="nav-text">流控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#延迟调用"><span class="nav-number">11.</span> <span class="nav-text">延迟调用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数"><span class="nav-number">12.</span> <span class="nav-text">函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#错误处理"><span class="nav-number">13.</span> <span class="nav-text">错误处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字符串"><span class="nav-number">14.</span> <span class="nav-text">字符串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数组"><span class="nav-number">15.</span> <span class="nav-text">数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#切片"><span class="nav-number">16.</span> <span class="nav-text">切片</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字典"><span class="nav-number">17.</span> <span class="nav-text">字典</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#结构"><span class="nav-number">18.</span> <span class="nav-text">结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法"><span class="nav-number">19.</span> <span class="nav-text">方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#接口"><span class="nav-number">20.</span> <span class="nav-text">接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#并发"><span class="nav-number">21.</span> <span class="nav-text">并发</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#通道"><span class="nav-number">22.</span> <span class="nav-text">通道</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">along</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
